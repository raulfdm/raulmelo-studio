// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`fn: getPostsToAlgolia returns expected data structure 1`] = `
Object {
  "date_timestamp": "1637107200",
  "excerpt": "Monorepo architecture has become more popular over the years, which is understandable considering the problem it solves. The biggest challenge, though, is finding an easy-to-use tool for handling such a structure.

If you Google \\"monorepo tool javascript\\", you'll find many articles showing the most popular options we have, and curiously each one attempts to solve that problem in a very different way.

From the options we have, some are there for a while (like Lerna) but no longer actively maintained; others never went out from draft (like Bolt), others are working fine but only for a specific kind of project.

Unfortunately, we don't have a killer tool that fits all types of JavaScript/Typescript projects and all sizes of teams, and that's understandable.

Yet there's one (\\"new\\") option that might help us in most cases: **pnpm workspaces**.

But before talking about pnpm, let me tell you my monorepo/workspaces usage and how I managed to solve that in the first place.



 My Blog

When I first created my blog, I bootstrapped a Next.js application, put it into a git repository, and pushed the scaffolding code there.

After a while, I needed to set up the CMS to hold my content. Then I created a Strapi application, put it into another git repository, and pushed it to another Github repo.

Then, I decided to fork a library called \`mdx-prism\` to fix some minor problems and automate its deployment. Once again, another new git repository containing its code and setup.

I had 3 git repos implied that I had 3 eslint, prettier, jest, babel, and typescript configs, but I handled it for a while.

Soon, I became bothered by every dependency update (like TypeScript); I had to update in all repositories (three pull requests). Every new thing I learned like a new eslint rule, I agree, I had to go in there and change three times and so on.

My first instinct was:

> What if I put all projects inside a single folder and repository, create my base config and use it to extend each project's config?

Unfortunately, I couldn't simply drop the files there, extend, and hope it works because things are more complex than that. The tools need module/file resolution, and I didn't want to ship all projects when I was about to deploy.

At that moment, I realized I needed a monorepo tool to do this linking and make my experience better.

I tried some solutions, and the easiest way to get up and running was Lerna + Yarn Workspaces.

Of course, along the setup process, I had had some gotchas like understanding why some builds were failing (not all apps likes hoisted dependencies), had to adapt my pipelines, and how I deployed each project. Still, I managed everything and had a decent setup.

With the bare minimum setup, I started to create even more small independent modules/apps to re-use, extend and try out new tools without impacting my existing code. That was the moment I saw with my own eyes how amazing it's working a monorepo.



 About Lerna + Yarn Workspaces

Lerna is a high-level monorepo tool that provides abstractions to simultaneously manage a single or multiple apps/packages. 

You can run commands (e.g., build, test, lint) for all the projects you control with a single command-line instruction, or if you prefer, you can even filter a specific project with the flag \`--scope\`.

Yarn Workspaces is a low-level tool that handles the packages installation, creates a symlink between projects, and allocates the modules in root and controlled projects folders.

You can use either Lerna or Yarn Workspaces to manage your repository, but you may have noticed that they are more complementary than exclusionary. In other words, they work really well together.

Even nowadays, this combination is still a good choice, but some \\"problems\\" might be highlighted:

- Yarn Workspaces (at least for v1) is no longer receiving new features and improvements (the last update was from 2018);
- Lerna documentation is OK, but you have to figure out a lot of things by yourself;
- Lerna publishing system is not as simple as it seems, especially to generate automated publishes with commit lint;
- You can easily get lost on understanding the commands you have to run or what commands are being run by other commands you invoke;
- Lerna CLI  has problems like [you cannot install multiple dependencies at the same time](https://github.com/lerna/lerna/issues/2004);
- Lerna CLI \`--scope\` is not reliable and hard to understand and use;
- There's a [wizard](https://github.com/webuniverseio/lerna-wizard) to help us with regular tasks, but it seems to be being maintained outside the main repo;
- [Lerna is currently unmaintained](https://github.com/lerna/lerna/issues/2703issuecomment-744601134);

By the time it was created (in 2015), Lerna had come up to help us with this lack of tooling to manage JS monorepos, and it did amazingly well.

Though because they might not have a dedicated team (or a few people) to work on that, plan the future of the tool, Lerna is slowly dyin",
  "featuredImage": Object {
    "height": 1260,
    "url": "https://cdn.sanity.io/images/gc3hakk3/production/f3be09a1be3373867ac367d2425e80c37958a9bb-2400x1260.png",
    "width": 2400,
  },
  "id": "fe63b616-8f70-44c3-9227-fd0625ca3103",
  "language": "en",
  "objectID": "Content_fe63b616-8f70-44c3-9227-fd0625ca3103",
  "slug": "replacing-lerna-and-yarn-with-pnpm-workspaces",
  "tags": Array [
    Object {
      "_id": "a98ba9c8-b2ec-4fdd-a47d-80714402d9b4",
      "name": "pnpm",
      "slug": "pnpm",
    },
    Object {
      "_id": "92be336e-3b55-40df-93e7-7942428bd8b9",
      "name": "Package Manager",
      "slug": "package-manager",
    },
    Object {
      "_id": "74087cc8-2774-4aa6-b39d-15f12e457351",
      "name": "JavaScript",
      "slug": "javascript",
    },
    Object {
      "_id": "7fc7bb85-6f69-4d28-a04d-1f1a29953880",
      "name": "Monorepo",
      "slug": "monorepo",
    },
  ],
  "title": "Replacing Lerna + Yarn with PNPM Workspaces",
}
`;

exports[`fn: getPostsToAlgolia returns expected data structure 2`] = `
Object {
  "date_timestamp": "1625702400",
  "excerpt": "Hey, devs.

Today I want to present to you a simpler and (IMO) better way to have installed different versions of the same runtime in your machine with a single tool called \`asdf\`.

The tool itself is relatively simple, the docs are well written and you won’t have trouble getting started asap.

Here I will just make a summary and present you some gotchas I had after a while using it.



 The Hell of Runtime Versions

Back in 2013 when I was learning development in college, I remember having a lot of trouble running some projects because they rely on a specific Java version.

“Oh, this one uses Java 5, I need to download the runtime. But wait, I already have Java 6 in my machine… damn”

This was very overwhelming, especially because I didn’t have much experience and back then my professors and colleagues didn’t know a better way of easing this problem.

In the first company I started work as a software developer, all backend apps were written in ruby and well… the exact same problem.

To avoid consuming the production/staging environment while I was coding my client-side application, I needed to run a couple of servers in my machine and, again, they required different ruby versions.

Luckily the backend team had a wiki page recommending to use a tool called RVM (Ruby Version Manager), which as the name already explains itself, is a CLI to control multiple ruby versions in our machine.

And it worked pretty well, to be honest.

After a while coding front-end applications, I started to see more often the same problem happening with node js.

> This project uses node 7. But I have node 10 installed... Oh no…

When I googled to find a similar solution as \`rvm\`, I found NVM (Node Version Manager), which does the same thing as \`rvm\` but for the Node runtime.

Ok, now I have 2 CLIs to handle the same problem.

It was then I started to study Go and thought: “oh, here we go again… another CLI”.

After I complained about that to a colleague he said:

> Why the heck don't you use \`asdf\` for all these languages?

And my mind explodes because of course, if I was bothered dealing with that, someone in the plant was bothered as well, and most importantly: he/she had already created a tool that solves this problem.



 The Master CLI: asdf

\`asdf\` is a CLI tool that solves the runtime version management in a well-architected and elegant way: by being a single tool for all runtimes.

The idea is that \`asdf\` is a core application that does the handling heavy-lifting of providing CLI options, being hooked via terminal, etc. but instead of also solving the version available for **every single runtime that exists**, it delegates this to third party plugins.

![asdf workflow](https://res.cloudinary.com/duzei21zt/image/upload/v1625743285/site/asdf_1_4ab74a00a5.png)

This means that \`asdf\` does not care about any runtime like java, go, deno, rust, or whatever, but it provides an abstract interface where someone in the community can simply create and maintain a plugin that provides all the information to download the version X for example.

If you’re familiar with Front-end development, this is pretty much like babel does. It handles our code but you can write your plugin that hooks there and do something else without creating a burden to the Babel’s team to maintain the code itself.

The following sections will show how the tooling works. If you want to try, you need to make sure that you have \`asdf\` properly installed and configured in your bash, fish, or zsh terminal configuration.

> [asdf installation guide](https://asdf-vm.com//core-manage-asdf?id=install)

 Plugins

As I mentioned, a plugin is a specific runtime manager. In that sense, the \`asdf-ruby\` plugin only deals with how to download ruby runtime, which version was released, etc.
Installing a plugin is relatively easy but I strongly recommend you check the plugin’s repository and see if there are more instructions needed before adding it.

> Check here [all plugins available](https://asdf-vm.com//plugins-all) for \`asdf\`

In general, the instruction follows the same basic way of installing, running \`asdf plugin add <plugin-name> <git-url>\`. The \`git-url\` isn’t required but recommended just to be sure you’re consuming for the correct repository:

\`\`\`bash
asdf plugin add nodejs
asdf plugin add ruby https://github.com/asdf-vm/asdf-ruby.git
\`\`\`

Now, my \`asdf\` will have 2 plugins: one capable to manage node versions and another to manage ruby versions.

 Versions

The plugin itself won’t add any version by default. It’s time to finally install some versions we want to use in some projects.

For this example I want to have in my machine:
Latest \`10.2\` version of node
Latest \`14\` version of node
Exact \`2.6.5\` version of Ruby
Latest \`2.7\` version of Ruby

For all these versions I'll run \`asdf install <plugin-name> <version>\`. So all I need to do is running in the terminal:

\`\`\`bash
asdf install nodejs latest:10.2
asdf install nodejs latest:14
asdf install ruby 2.6.5
asdf instal",
  "featuredImage": Object {
    "height": 3316,
    "url": "https://cdn.sanity.io/images/gc3hakk3/production/e97a867f0e9443c42b8a042e3d714c8594f36f08-5196x3316.jpg",
    "width": 5196,
  },
  "id": "c1d296f4-35b0-41c2-99be-beff7583f193",
  "language": "en",
  "objectID": "Content_c1d296f4-35b0-41c2-99be-beff7583f193",
  "slug": "how-to-manage-multiple-runtime-versions-with-a-single-tooling",
  "subtitle": "A quick walkthrough on asdf CLI",
  "tags": Array [
    Object {
      "_id": "96f6acec-77a2-4940-b09d-51bb6d036f53",
      "name": "Tooling",
      "slug": "tooling",
    },
    Object {
      "_id": "fbdf4642-4a9b-4feb-93ca-64e57f8bb9f6",
      "name": "Software Development",
      "slug": "software-development",
    },
    Object {
      "_id": "923bef9b-658c-40cd-8b8a-42291e5d8268",
      "name": "Runtime Management",
      "slug": "runtime-management",
    },
  ],
  "title": "How to Manage Multiple Runtime Versions With a Single Tooling",
}
`;

exports[`fn: getPostsToAlgolia returns expected data structure 3`] = `
Object {
  "date_timestamp": "1625097600",
  "excerpt": "Hello, devs.

Today I want to dive deep into a very specific data structure to hold a collection that's called Linked List.

First I'll briefly explain the array problem and how linked lists came to solve those problems and then we'll how to implement that in JavaScript.

I already can say that as a JS dev I don't see big use cases because we have natively a pretty decent way of handling collections. However, as a software engineer, I consider it very important to have a base understanding of it in case I need it in the future.

> Knowledge is power and never useless.



 About Lists

Arrays are one of the most efficient ways of storing data collections like a list of friends on Instagram for example.

In JavaScript when we want to create a list of something, all we need is a very simple open/close square bracket (\`[]\`) and push as many elements you want to it.

However in some other languages, especially the ones which are focus on performance the approach is different. There, if you need a list, you have to specify the size of your list, which sometimes is a problem because we often handle dynamic data.

And it makes sense to have this approach. If you have little memory and need to write some code that compiles a very low machine language (like binary) if you say that your list will have only 3 elements, for example, the compiler can say:

> Hey, for this list here can be allocated only a few bytes because we know in advance it'll only contain a max of 3 elements

Also, if you want to insert or remove an element in some specific position, you need to entirely move the list and these operations could be tedious and expensive.

In JS we don't suffer much about that because the language was designed in that way and we also have native array methods (very well optimized I suppose) that remove or add an element and regen the list, like the method [\`Array.prototype.splice()\`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice).

\`\`\`js
const months = ['Jan', 'March', 'April', 'June'];

// insert exactly in the index one (1, 0) the string \`Feb\`
months.splice(1, 0, 'Feb');

console.log(months); // Array [\\"Jan\\", \\"Feb\\", \\"March\\", \\"April\\", \\"June\\"]

// removes everything from the index 3 til the last el (\\"April\\" and \\"June\\")
months.splice(3, months.length)

console.log(months); // [\\"Jan\\", \\"Feb\\", \\"March\\"]
\`\`\`



 Linked List: Concept

Linked list implementation tries to solve the max number of elements we can store in a list and how to easily navigate through a list by change the data structure used from arrays to simple linked objects (node).

Every node will have 2 properties:

- \`element\`: the data we want to store in our list;
- \`next\`: a link to another node or the value null (non-existing next node).

Maybe the best way to visualize it is by imagining a train.

In a train we always have the \\"head\\" which and from there it's connected the first \\"wagon\\", then a second \\"wagon\\" is connected to the first until the end of the train.

If we want to remove a defective wagon, for example, all we need to do is find this wagon, link the previous wagon to the next wagon, and done.

The principle is the same when we want to add a new \\"wagon\\". All we need is to find where we want to add it, connect the previous and the next wagon into the new one.

In other words, linked lists are all about creating and modifying connections between nodes.

In the next section, we'll step-by-step implement all those additions and removals and you'll that it's a relatively simple concept.



 Linked List: Implementation

Before any implementation, let's take a look in the API we'll need for this kind of list:

- \`.append(element)\` - method used to append a new element to the end of the list;
- \`.indexOf(element)\` - method used to known where in the index our element was added;
- \`.insertAt(position, element)\` - method used to add an element in a specific position;
- \`.remove(element)\` - method used to remove an element from the list;
- \`.removeAt(position)\` - method used to remove an element in some specific position;
- \`.toString()\` - method used to have an overview of our list.

Once again, instead using JS classes/prototype, I'm going to use my favorite pattern Factory with some placeholders for our API already:

\`\`\`js
function LinkedListFactory() {
  return {
    append,
    indexOf,
    insertAt,
    remove,
    removeAt,
    toString,
  };

  function append(element) {}

  function indexOf(element) {}

  function insertAt(position, element) {}

  function remove(element) {}

  function removeAt(position) {}

  function toString() {}
}
\`\`\`

 \\"Global\\" variables

Before implementing the methods, we'll need to create 2 variables that will be used in almost all methods:

- \`head\` - variable to hold our very first element, where everything will start. It'll start with the value \`null\`;
- \`length\` - a control variable to easily hold the list size. It'll start with the value \`0\`.

\`\`\`js
function LinkedList",
  "featuredImage": Object {
    "height": 4000,
    "url": "https://cdn.sanity.io/images/gc3hakk3/production/4ecac30d3d148098bc511364a9074ac94ebf2543-6000x4000.jpg",
    "width": 6000,
  },
  "id": "9260ffdc-e0b9-4706-a36b-beae7b7c3f2d",
  "language": "en",
  "objectID": "Content_9260ffdc-e0b9-4706-a36b-beae7b7c3f2d",
  "slug": "data-structure-with-javascript-linked-list",
  "subtitle": "What is and how to implement a basic linked list in JavaScript",
  "tags": Array [
    Object {
      "_id": "5ef50e3e-954a-4f07-a17a-a4c95cd780dc",
      "name": "Computer Science",
      "slug": "computer-science",
    },
    Object {
      "_id": "8db1ecbb-65fa-4526-bd3b-b33aa68c15fa",
      "name": "Data Structure",
      "slug": "data-structure",
    },
  ],
  "title": "Data Structure with JavaScript: Linked List",
}
`;

exports[`fn: getPostsToAlgolia returns expected data structure 4`] = `
Object {
  "date_timestamp": "1621641600",
  "excerpt": "When we talk about queue as a data structure, it's exactly the same as you can imagine in real-world examples: a lot of things a line one in front of the other, waiting for something, like the imagine hero shows.

In this post, we're gonna talk about the basic implementation of a queue (like a supermarket queue), a priority queue (like a hospital queue), and also a circular queue (like a list of things you have to do repetitively).

 Basic Queue

The basic queue will give us the base for the other queues. Here, we need to implement a mechanism called FIFO (First In, First Out), which means the first element added will be the first to be removed.

To start, let's see the API interface we need to implement that:

- \`enqueue(element)\` - add new element(s) to the queue;
- \`dequeue()\` - remove first element from the queue;
- \`front()\` - returns the first element from the queue (for checking purposes);
- \`isEmpty()\` - returns if the queue is empty or not;
- \`size()\` - returns how many elements the queue contains.

> Keep in mind that the API might differ from different languages which have Queue native or other implementations, but the principles are the same.

There are many ways of creating this structure, some people would straight use JS class but personally, I like to use the \`factory\` approach.

So let's create a factory function with a placeholder for all those methods:

\`\`\`js
function QueueFactory() {
  const items = [];

  return {
    enqueue,
    dequeue,
    front,
    isEmpty,
    size,
  };

  function enqueue() {}

  function dequeue() {}

  function front() {}

  function isEmpty() {}

  function size() {}
}
\`\`\`

 .enqueue(element)

This method will simple take an element as argument and add to the end of the list:

\`\`\`js
function enqueue(element) {
  items.push(element)
}
\`\`\`

 .dequeue()

Dequeue will remove the first element of our items and return it. We can simple use \`Array.prototype.shift\` for that task:

\`\`\`js
function dequeue() {
  return items.shift();
}
\`\`\`

> Friendly reminder that shift mutates \`items\` array.

 .front()

This method will only return for visibility purposes the first element of the list:

\`\`\`js
function front() {
  return items[0];
}
\`\`\`

 .isEmpty()

As the name says, this method will check if our queue is empty or not:

\`\`\`js
function isEmpty() {
  return items.length === 0;
}
\`\`\`

 .size()

This will simply return the length of our list:

\`\`\`js
function size() {
  return items.length;
}
\`\`\`

 (Optional) .print() / .queue()

It's important that we don't expose our queue as part of the public interface because the whole idea is having a custom implementation for arrays.

Also, arrays are mutable, which means that if the user (we or other devs) push has access to the reference, new elements could be pushed or removed.

So if you want to provide a method to check the entire list, you could return a copy of this list:

\`\`\`js
function queue() {
  return [...items];
}
\`\`\`

Or maybe a method which prints the list:

\`\`\`js
function print() {
  console.log(items.toString());
  // or console.log(JSON.stringify(items))
}
\`\`\`

 Final result

\`\`\`js
function QueueFactory() {
  const items = [];

  return {
    enqueue,
    dequeue,
    front,
    isEmpty,
    size,
    print
  };

  function enqueue(element) {
    items.push(element);
  }

  function dequeue() {
    return items.shift();
  }

  function front() {
    return items[0];
  }

  function isEmpty() {
    return items.length === 0;
  }

  function size() {
    return items.length;
  }

  function print() {
    console.log(items.toString());
  }
}


const myQueue = QueueFactory();

myQueue.enqueue(3);
myQueue.enqueue(2);
myQueue.enqueue(6);

console.log(myQueue.front()); // 3
myQueue.print(); // 3,2,6

console.log(myQueue.dequeue()); // 3
myQueue.print(); // 2,6
\`\`\`



 Priority Queue

In some cases, only the basic queue isn't enough. We need that behavior but we also want to take into account priorities, like a hospital emergency queue where the worst case has the highest priority no matter when it arrives first.

The good news is that from our previous implementation, only a few changes will be necessary.

 Internal data structure

Before we were simply pushing the element we received from our \`enqueue\` method into a list.


Now, to keep tracking which element has higher or lower priority we might want to have an internal structure, a simple object where we simply hold the element and the priority:

\`\`\`js
function createQueueElement(element, priority) {
  return {
    element,
    priority,
  };
}
\`\`\`

Now, iniside the \`enqueue\` method, we have to also accept a priority, so we create our element with our internal structure:


\`\`\`js
function enqueue(element, priority) {
  const newEl = createQueueElement(element, priority);
  
  items.push(newEl)
}
\`\`\`

Nothing has changed until here, only our internal data structure.

 Priority

To take into account where to add the element we'll need to loop over all items and check if ",
  "featuredImage": Object {
    "height": 3648,
    "url": "https://cdn.sanity.io/images/gc3hakk3/production/7228f4b494fc6dc189da4dd31ec908bb39659ae3-5472x3648.jpg",
    "width": 5472,
  },
  "id": "826a32b0-6718-4327-a592-6da0bda52e98",
  "language": "en",
  "objectID": "Content_826a32b0-6718-4327-a592-6da0bda52e98",
  "slug": "data-structure-with-javascript-queue",
  "subtitle": "How to implement basic, priority and circular queue in JavaScript.",
  "tags": Array [
    Object {
      "_id": "5ef50e3e-954a-4f07-a17a-a4c95cd780dc",
      "name": "Computer Science",
      "slug": "computer-science",
    },
    Object {
      "_id": "8db1ecbb-65fa-4526-bd3b-b33aa68c15fa",
      "name": "Data Structure",
      "slug": "data-structure",
    },
  ],
  "title": "Data Structure with JavaScript: Queue",
}
`;

exports[`fn: getPostsToAlgolia returns expected data structure 5`] = `
Object {
  "date_timestamp": "1618531200",
  "excerpt": "As a JavaScript developer (no matter back or front-end), we often rely upon \`npm scripts\` to automate common tasks like starting a server, building a project, and even performing tasks before or after certain scripts like \`postbuild\`, \`prebuild\`, etc.

When those commands are simple like \`node index.js\`, having them a single line in our package.json isn't a problem at all. The real problem starts when we need an extensive command, adding environment variables, and concatenating commands:

(Example extracted from [Material UI package.json](https://github.com/mui-org/material-ui/blob/830c18ba71af19bc0370f1eeb902f9f605144a5d/package.json))
\`\`\`json
{
    \\"scripts\\": {
      \\"proptypes\\": \\"cross-env BABEL_ENV=development babel-node --extensions \\\\\\".tsx,.ts,.js\\\\\\" ./scripts/generateProptypes.ts\\",
      \\"deduplicate\\": \\"node scripts/deduplicate.js\\",
      \\"benchmark:browser\\": \\"yarn workspace benchmark browser\\",
      \\"build:codesandbox\\": \\"lerna run --parallel --scope \\\\\\"@material-ui/*\\\\\\" build\\",
      \\"release:version\\": \\"lerna version --exact --no-changelog --no-push --no-git-tag-version\\",
      \\"release:build\\": \\"lerna run --parallel --scope \\\\\\"@material-ui/*\\\\\\" build\\",
      \\"release:changelog\\": \\"node scripts/releaseChangelog\\",
      \\"release:publish\\": \\"lerna publish from-package --dist-tag next --contents build\\",
      \\"release:publish:dry-run\\": \\"lerna publish from-package --dist-tag next --contents build --registry=\\\\\\"http://localhost:4873/\\\\\\"\\",
      \\"release:tag\\": \\"node scripts/releaseTag\\",
      \\"docs:api\\": \\"rimraf ./docs/pages/api-docs && yarn docs:api:build\\",
      \\"docs:api:build\\": \\"cross-env BABEL_ENV=development __NEXT_EXPORT_TRAILING_SLASH=true babel-node --extensions \\\\\\".tsx,.ts,.js\\\\\\" ./docs/scripts/buildApi.ts  ./docs/pages/api-docs ./packages/material-ui-unstyled/src ./packages/material-ui/src ./packages/material-ui-lab/src --apiPagesManifestPath ./docs/src/pagesApi.js\\",
      \\"docs:build\\": \\"yarn workspace docs build\\",
      \\"docs:build-sw\\": \\"yarn workspace docs build-sw\\",
      \\"docs:build-color-preview\\": \\"babel-node scripts/buildColorTypes\\",
      \\"docs:deploy\\": \\"yarn workspace docs deploy\\",
      \\"docs:dev\\": \\"yarn workspace docs dev\\",
      \\"docs:export\\": \\"yarn workspace docs export\\",
      \\"docs:icons\\": \\"yarn workspace docs icons\\",
      \\"docs:size-why\\": \\"cross-env DOCS_STATS_ENABLED=true yarn docs:build\\",
      \\"docs:start\\": \\"yarn workspace docs start\\",
      //.....
    }
}
\`\`\`


But what if I told you could have those commands extracted into a separate file and having a \`scripts\` config like this:

\`\`\`json
{
    \\"scripts\\": {
      \\"proptypes\\": \\"scripty\\",
      \\"deduplicate\\": \\"scripty\\",
      \\"benchmark:browser\\": \\"scripty\\",
      \\"build:codesandbox\\": \\"scripty\\",
      \\"release:version\\": \\"scripty\\",
      \\"release:build\\": \\"scripty\\",
      \\"release:changelog\\": \\"scripty\\",
      \\"release:publish\\": \\"scripty\\",
      \\"release:publish:dry-run\\": \\"scripty\\",
      \\"release:tag\\": \\"scripty\\",
      \\"docs:api\\": \\"scripty\\",
      \\"docs:api:build\\": \\"scripty\\",
      \\"docs:build\\": \\"scripty\\",
      \\"docs:build-sw\\": \\"scripty\\",
      \\"docs:build-color-preview\\": \\"scripty\\",
      \\"docs:deploy\\": \\"scripty\\",
      \\"docs:dev\\": \\"scripty\\",
      \\"docs:export\\": \\"scripty\\",
      \\"docs:icons\\": \\"scripty\\",
      \\"docs:size-why\\": \\"scripty\\",
      \\"docs:start\\": \\"scripty\\",
    }
   //.....
}
\`\`\`



 Scripty

Scripty is a npm package that enables us the ability to have executable files to run \`npm scripts\`.

The whole idea is to treat these giant script lines we have as code and keep our package.json clean and simple.

Let's say we have this:

\`\`\`json
{
  \\"scripts\\": {
    \\"lint\\": \\"eslint . --cache --report-unused-disable-directives --ext .js,.ts,.tsx --max-warnings 0\\"
  }
}

\`\`\`

Using scripty it'll look like this:

\`\`\`json
{
  \\"scripts\\": {
    \\"lint\\": \\"scripty\\"
  }
}
\`\`\`

 The magic behind

Of course, the command we just removed needs to be somewhere. To make it simple as that, scripty does a pairing of \`<npm-script-nam>:<executable-file-name>\`.

In other words, if we have an npm script called \`lint\`, we need an executable file called \`lint\`, \`lint.sh\`, or \`lint.js\`.


The default folder is always, at the root level, a folder called \`scripts\`. So, to solve the previous migration, we would create a file called \`lint.sh\` under the \`scripts\` folder, like this:


\`\`\`bash
!/usr/bin/env bash

yarn eslint . --cache --report-unused-disable-directives --ext .js,.ts,.tsx --max-warnings 0
\`\`\`

 Executable Bash or .JS

Scripty can handle only handle bash or JavaScript executables.

To have one of those, the file needs to:

1. having the shebang at the top of the file (e.g. \`!/bin/bash\` or \`!/bin/node\`;
2. having permission to execute (while \`ls -la\`, it needs to have \`x\` flag);

> Quick tip, if you're in a UNIX environment, you can quickly give this permission by running the command \`chmod u+x <file-path>\`


Also, file extensions are not necessary. You can write a \`test.sh\`, \`test.js\` or only \`test\`. What will define the syntax highlight and the execution w",
  "featuredImage": Object {
    "height": 4312,
    "url": "https://cdn.sanity.io/images/gc3hakk3/production/cde16fb7505ac11b315af8b5ca9179c284a6e6b5-6468x4312.jpg",
    "width": 6468,
  },
  "id": "80be37b1-a1d9-4931-975b-1cf4640f7f7d",
  "language": "en",
  "objectID": "Content_80be37b1-a1d9-4931-975b-1cf4640f7f7d",
  "slug": "how-to-have-better-npm-scripts",
  "subtitle": "A quick npm package to ease your complex npm scripts",
  "tags": Array [
    Object {
      "_id": "74087cc8-2774-4aa6-b39d-15f12e457351",
      "name": "JavaScript",
      "slug": "javascript",
    },
    Object {
      "_id": "96f6acec-77a2-4940-b09d-51bb6d036f53",
      "name": "Tooling",
      "slug": "tooling",
    },
  ],
  "title": "How to have better NPM Scripts",
}
`;
